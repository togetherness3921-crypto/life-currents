// .github/scripts/run_codex_instance.cjs

const { execSync } = require('child_process');
const { createClient } = require('@supabase/supabase-js');

// A helper function to run shell commands and log their output.
// Throws an error if the command fails.
function runCommand(command) {
  console.log(`\n[RUNNING]: ${command}`);
  try {
    const output = execSync(command, {
      stdio: 'pipe',
      env: {
        ...process.env,
        RUST_LOG: 'trace',
        RUST_BACKTRACE: '1',
      },
    }).toString();
    console.log(`[OUTPUT]: ${output.trim()}`);
    return output.trim();
  } catch (error) {
    console.error(`[ERROR]: Command failed: ${command}`);
    // Log all parts of the error object for maximum debuggability
    if (error.stdout) console.error(`[STDOUT]: ${error.stdout.toString()}`);
    if (error.stderr) console.error(`[STDERR]: ${error.stderr.toString()}`);
    if (error.status) console.error(`[EXIT CODE]: ${error.status}`);
    throw error;
  }
}

// A helper function to poll for the Cloudflare URL.
async function getPreviewUrl(commitSha) {
  console.log(`\nPolling for Cloudflare preview URL for commit: ${commitSha}...`);
  const maxRetries = 20; // Try for up to 10 minutes (20 * 30s)
  for (let i = 0; i < maxRetries; i++) {
    try {
      const command = `gh api repos/${process.env.GITHUB_REPOSITORY}/deployments --param sha=${commitSha}`;
      const deploymentsJson = runCommand(command);
      const deployments = JSON.parse(deploymentsJson);

      const successDeployment = deployments.find(
        (d) => d.environment === 'Preview'
      );

      if (successDeployment) {
        const statusesJson = runCommand(`gh api ${successDeployment.statuses_url}`);
        const statuses = JSON.parse(statusesJson);
        const latestStatus = statuses.find(s => s.state === 'success');
        if (latestStatus && latestStatus.environment_url) {
          console.log(`\nâœ… Success! Found preview URL: ${latestStatus.environment_url}`);
          return latestStatus.environment_url;
        }
      }
    } catch (error) {
      console.log(`Attempt ${i + 1}/${maxRetries}: Deployment not ready yet. Retrying in 30 seconds...`);
    }
    await new Promise(resolve => setTimeout(resolve, 30000)); // Wait 30 seconds
  }
  throw new Error('Timed out waiting for Cloudflare preview URL.');
}

async function main() {
  const {
    CODEX_PROMPT,
    INSTANCE_NUMBER,
    SUPABASE_URL,
    SUPABASE_ANON_KEY,
    GH_TOKEN,
    OPENAI_API_KEY, // Explicitly pull this for the check
  } = process.env;

  // --- 0. Pre-flight Checks ---
  console.log('--- Starting Workflow ---');
  if (!CODEX_PROMPT || !GH_TOKEN || !SUPABASE_URL || !SUPABASE_ANON_KEY || !OPENAI_API_KEY) {
    throw new Error('One or more required environment variables are missing.');
  }
  console.log(`OPENAI_API_KEY found with length: ${OPENAI_API_KEY.length}`);


  // --- 1. Git Setup ---
  runCommand(`git config user.name "Codex Agent"`);
  runCommand(`git config user.email "codex-agent@users.noreply.github.com"`);

  const date = new Date().toISOString().split('T')[0];
  const uniqueSuffix = Math.random().toString(36).slice(2, 8);
  const branchName = `codex-build-${date}-instance-${INSTANCE_NUMBER}-${uniqueSuffix}`;
  runCommand(`git checkout -b ${branchName}`);
  console.log(`\nCreated new branch: ${branchName}`);

  // --- 2. Codex Configuration ---
  console.log(`\nConfiguring Codex CLI to use API key authentication...`);
  runCommand('mkdir -p ~/.codex');
  runCommand('echo \'preferred_auth_method = "apikey"\' > ~/.codex/config.toml');
  runCommand('cat ~/.codex/config.toml'); // Verify file contents
  runCommand('bash -lc \'codex login --api-key "$OPENAI_API_KEY"\'');

  // --- 3. Codex Health Check ---
  console.log(`\nRunning Codex health check...`);
  runCommand(`codex --version`);

  // --- 4. Run Codex ---
  console.log(`\nRunning Codex with prompt...`);
  const model = process.env.CODEX_MODEL || 'gpt-5-codex';
  runCommand(`codex exec --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check --config tools.web_search=true --model ${model} "${CODEX_PROMPT}"`);

  // --- 5. Check for Changes ---
  const status = runCommand('git status --porcelain');
  if (!status) {
    console.log('\nCodex made no changes. Exiting gracefully.');
    return;
  }
  console.log('\nCodex made changes. Proceeding to commit.');

  // --- 6. Commit and Push ---
  runCommand('git add .');
  runCommand(`git commit -m "feat: Implement changes from prompt (Instance ${INSTANCE_NUMBER})"`);
  runCommand(`git push origin ${branchName}`);

  // --- 7. Create Pull Request ---
  const prTitle = `Codex Build (Instance ${INSTANCE_NUMBER}): ${CODEX_PROMPT.substring(0, 50)}...`;
  const prBody = `This PR was automatically generated by the Codex Engine (Instance ${INSTANCE_NUMBER}) based on the following prompt:\n\n---\n\n> ${CODEX_PROMPT}`;
  const prResult = runCommand(`gh pr create --title "${prTitle}" --body "${prBody}" --fill`);

  const prUrl = prResult.match(/https?:\/\/\S+/)[0];
  const prNumber = prUrl.split('/').pop();
  console.log(`\nCreated PR #${prNumber} at: ${prUrl}`);

  const commitSha = runCommand(`git rev-parse HEAD`);

  // --- 8. Get Cloudflare URL ---
  const previewUrl = await getPreviewUrl(commitSha);

  // --- 9. Update Supabase ---
  console.log(`\nUpdating Supabase with build details...`);
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  const { data, error } = await supabase
    .from('preview_builds')
    .insert([{
      pr_number: parseInt(prNumber, 10),
      pr_url: prUrl,
      commit_sha: commitSha,
      preview_url: previewUrl,
      status: 'pending_review',
      is_seen: false,
    }]);

  if (error) {
    console.error('Error updating Supabase:', error);
    throw new Error(`Failed to insert build record into Supabase: ${error.message}`);
  }

  console.log('\nðŸš€ Workflow complete! Build record saved to Supabase.');
}

// Run the main function and exit with a non-zero code on error.
main().catch(error => {
  console.error('\n--- Workflow Failed ---');
  // Log the full error object, not just the message
  console.error(error);
  process.exit(1);
});
